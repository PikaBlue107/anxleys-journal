/* 
 * This program is composed of two java files:
 * YoutubeUserCommentHunter.java: Main program, contains the main API logic and
 * 		many helper methods to aid in data processing and writeout.
 * ExtendableGenericArray.java: Custom collections-ish (no extend) to let me
 * 		index into anywhere in an array, and store a generic object where I
 * 		couldn't directly.
 * 
 * Everything should be documented relatively well, so if you're wondering how
 * you can do something like this, feel free to take a look around. There's some
 * API integration, file IO, and string processing, plus the generics and array
 * extending semantics in the array class I wrote.
 */
/*----------------------------------------------------
 * YoutubeUserCommentHunter.java
 *--------------------------------------------------*/
package YoutubeAPIGradle;

import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.security.GeneralSecurityException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;

import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
import com.google.api.client.googleapis.json.GoogleJsonResponseException;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.JsonFactory;
import com.google.api.client.json.jackson2.JacksonFactory;
import com.google.api.services.youtube.YouTube;
import com.google.api.services.youtube.model.Comment;
import com.google.api.services.youtube.model.CommentSnippet;
import com.google.api.services.youtube.model.CommentThread;
import com.google.api.services.youtube.model.CommentThreadListResponse;

/**
 * This class uses the YouTube Data API v3 to scan a youtube video for all
 * comments by a target channel id (commenter), and compile their comments into
 * an HTML file.
 * 
 * @author Melody Griesen
 *
 */
public class YoutubeUserCommentHunter {

	// MODIFIABLE PARAMETERS
	/** Video that we're scanning for comments. */
	private static final String VIDEO_ID = "UwxatzcYf9Q";
	/**
	 * Channel ID of the user whose comments we are isolating. This is Anxley's
	 * channel ID.
	 */
	private static final String TARGET_CHANNEL_ID = "UCSr1Me3Ls-4_lIpYsK_A7nA";

	// FIXED PARAMETERS
	// Misc
	/** Pastebin link where the source code is held. */
	private static final String CODE_PASTE = "https://github.com/PikaBlue107/anxleys-journal";
	/** Date time format for printing out comments. */
	private static final String DATE_TIME_FORMAT = "MMMM d, uuuu (h:mm a)";
	/** Name of the application. */
	private static final String APPLICATION_NAME = "YouTube User Comment Hunter";
	// Files
	/** File storing my developer key. Do not steal. */
	private static final String DEVELOPER_KEY_FILE = "src/main/resources/developer_key.prop";
	/** Output file for the generated HTML. */
	private static final String OUT_FILE = "src/main/resources/index.html";
	// HTML File Contents
	/** Header string from Melody, developer. */
	private static final String HEADER_NOTE = "Note from Melody, the gal who created this:\n"
			+ "This paste was generated by a Java program I wrote that uses the YouTube Data API v3.\n"
			+ "I'm going to try to keep this updated with the latest posts roughly every week.\n"
			+ "To see the code that generates these pages, look <a href=" + CODE_PASTE + ">here</a>.\n"
			+ "Much love from your local trans woman,\n" + "\tMelody Griesen <3";
	/** Start of the HTML document. */
	private static final String HTML_START = "<!DOCTYPE html>\r\n" + "<html>\r\n" + "<head>\r\n"
			+ "	<title>Anxley's 365 Day Challenge</title>\r\n" + "</head>\r\n" + "<body>";
	/** End of the HTML document. */
	private static final String HTML_END = "</body>" + "</html>";

	// VARIABLES
	/** List of comments, organized by day. */
	private static ExtendableGenericArray<List<Comment>> commentsByDay;
	/** Collection of all comments that we don't recognize a day for. */
	private static List<Comment> unrecognizedComments;
	/** Next page token to use when requesting a page of data. */
	private static String nextPageToken;
	/** JSON Factory for creating the YouTube object. */
	private static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();

	/**
	 * Build and return an authorized API client service.
	 *
	 * @return an authorized API client service
	 * @throws GeneralSecurityException, IOException
	 */
	public static YouTube getService() throws GeneralSecurityException, IOException {
		final NetHttpTransport httpTransport = GoogleNetHttpTransport.newTrustedTransport();
		return new YouTube.Builder(httpTransport, JSON_FACTORY, null).setApplicationName(APPLICATION_NAME).build();
	}

	/**
	 * Call function to create API service object. Define and execute API request.
	 * Loop over each page of responses, collecting comments. Filter by comments
	 * that match the target channel ID. When done, print out all found comments.
	 *
	 * @throws GeneralSecurityException, IOException, GoogleJsonResponseException
	 */
	public static void main(String[] args) throws GeneralSecurityException, IOException, GoogleJsonResponseException {
		// Get the YoTube object we need to perform API calls.
		YouTube youtubeService = getService();

		// Load our developer key from the file
		// First, get the property file loaded
		Properties prop = new Properties();
		prop.load(new FileInputStream(DEVELOPER_KEY_FILE));

		// Then, load the "key" property from the file (in the file, it looks like
		// "key=...")
		final String DEVELOPER_KEY = prop.getProperty("key");

		/*
		 * Define the API request.
		 * 
		 * 1. Specify a comment threads request.
		 * 
		 * 2. Ask for just the comment snippets, AKA just the top-level comments.
		 * 
		 * 3. Set my developer key so that I can authenticate with YouTube.
		 * 
		 * 4. Set the video ID for the video that we're scanning.
		 * 
		 * 5. Get the max results (100) per page.
		 * 
		 * 6. Sort by relevance (as opposed to "time"), because Anxley is popular, so
		 * more of their comments will be at the top by that sorting.
		 */
		YouTube.CommentThreads.List request = youtubeService.commentThreads()
				.list(Arrays.asList("snippet"/* , "replies" */)).setKey(DEVELOPER_KEY).setVideoId(VIDEO_ID)
				.setMaxResults((long) 100).setOrder("relevance");

		// Initialize our comment fields
		commentsByDay = new ExtendableGenericArray<List<Comment>>();
		unrecognizedComments = new ArrayList<Comment>();

		// Set up the next page token for the first iteration. For the first page, any
		// random string will do - we'll set it after we get the first response.
		nextPageToken = "FIRST PAGE";

		// While there's another page of data
		while (nextPageToken != null) {

			// Execute the API call to get one page of responses.
			CommentThreadListResponse response = request.execute();

			// Loop over all of the CommentThreads we got in this page
			for (CommentThread ct : response.getItems()) {
				// Call our helper method to handle this CommentThread
				processComment(ct.getSnippet().getTopLevelComment());
			}

			// Get the token of the next page of comments to read
			nextPageToken = response.getNextPageToken();
			// Use that token to prep the next request to get the next page of comments.
			request.setPageToken(nextPageToken);
		}
		// Done scanning in data from YouTube!

		// Time to print it out all nice and pretty-like into an HTML file.
		writeToFile(OUT_FILE);
	}

	/**
	 * Process one CommentThread, a.k.a. top-level comment. If it doesn't match the
	 * target channel ID, skip it. Otherwise, try to figure out what day it is and
	 * add it to that day in the commentsByDay list. Otherwise, add it to the
	 * unrecognizedComments list.
	 * 
	 * @param ct the CommentThread to parse and maybe
	 */
	private static void processComment(Comment comment) {
		// Get just the top-level snippet - this contains all of the useful data like
		// author, comment text, likes, date, etc.
		CommentSnippet topLevelSnippet = comment.getSnippet();

		// Get the Author's channel id
		String authorChannelId = topLevelSnippet.getAuthorChannelId().getValue();

		// If the channel ID of this comment matches the target ID
		if (authorChannelId.equals(TARGET_CHANNEL_ID)) {

			// Try to identify which day the comment was written, so that we can place it in
			// the commentsByDay list
			try {
				// Get day from the comment
				int day = getDayFromComment(comment);

				// Make sure the Days array has a List for that entry
				if (commentsByDay.get(day) == null) {
					commentsByDay.set(day, new ArrayList<Comment>());
				}
				// Add this comment to the list for this day
				commentsByDay.get(day).add(comment);
				// Yay! We registered it by day

			} catch (IllegalArgumentException e) {
				// Oops! This comment doesn't match the expected format.
				// Better add it to our unknowns list.
				unrecognizedComments.add(comment);
			}
		}
	}

	/**
	 * Write the data in the two comment lists to the output file in HTML format.
	 * 
	 * @param outfile the file to output the data to
	 * @throws IOException if cannot write to the outfile
	 */
	private static void writeToFile(String outfile) throws IOException {
		// Start by opening the file itself
		BufferedWriter out = new BufferedWriter(new FileWriter(outfile));

		// Write the header HTML information
		out.write(HTML_START);

		// Write the programmer info header
		out.write("<pre>" + HEADER_NOTE + "</pre>");

		// Write the start of the list!
		out.write("<h1>Anxley's 365 Day Challenge</h1>");

		// Start an unordered list
		out.write("<ul>\n");

		// Loop over our daily list
		for (int i = 1; i < commentsByDay.length(); i++) {

			// Start one list item
			out.write("<li>\n");

			// Get the list of comments for each day
			List<Comment> entries = commentsByDay.get(i);

			// If null, we haven't seen a comment for this day.
			if (entries == null) {
				// Oh no!
				out.write("<em>No comment for day " + i + "!</em>");
			}
			// Otherwise, there's at least one comment to print.
			else {
				// If we've got more than 1 comment for the day
				if (entries.size() > 1) {
					// Let the user know we've got multiple comments for this day.
					out.write("<em>" + entries.size() + " comments for this day!</em>");
				}

				// Print out each comment
				for (Comment c : entries) {
					out.write("<pre style=\"font-family: Roboto, Arial, sans-serif;\">" + printComment(c) + "</pre>");
				}

			}
			// End list item
			out.write("</li>");
		}

		// End the unordered list
		out.write("</ul>");

		// Loop over our unknowns
		out.write("<p>Unrecognizable comments from Anxley:</p>");
		if (unrecognizedComments.size() > 0) {
			// Start another unordered list
			out.write("<ul>");
			// For each unrecognized comment, print out just its text
			for (Comment comm : unrecognizedComments) {
				out.write(comm.getSnippet().getTextDisplay());
			}
			// Finish unordered list
			out.write("</ul>");
		}
		// If we had no unrecognized comments, let the user know
		else {
			out.write("<p>(none)</p>");
		}

		// Write the end of the HTML file
		out.write(HTML_END);
		// Close the output stream. All done!
		out.close();
	}

	/**
	 * Creates a String holding the data for one Comment. Each string holds the
	 * comment string, then one line each for likes, date, and URL.
	 * 
	 * @param comment the comment to print
	 */
	private static String printComment(Comment comment) {
		// Use a StringBuilder to compile all of the things
		StringBuilder sb = new StringBuilder();

		// Get the content of the comment itself
		String commentStr = comment.getSnippet().getTextDisplay();
		// Replace special characters
		commentStr = commentStr.replace("&#39;", "'").replace("<br />", "\n");
		// Print out comment itself
		sb.append("<div style=\"font-size: 15px;\">" + commentStr + "</div>");

		// Get the comment's like count
		Long likeCount = comment.getSnippet().getLikeCount();
		// Print out comment likes
		sb.append("\t\t\tLikes: " + likeCount + "\n");

		// Get the comment's (pretty) post date
		String prettyDate = getPrettyDate(comment);
		// Get a URL for this comment
		String url = getURLForComment(comment);
		// Print out URL
		sb.append("\t\t\t<a target=\"_blank\" href=" + url + ">" + prettyDate + "</a>");

		// Return built string
		return sb.toString();
	}

	/**
	 * Retrieves the publication date of the specified comment, and returns it in a
	 * nice format specified by DATE_TIME_FORMAT.
	 * 
	 * @param comment the comment to get the date of
	 * @return a nicely formatted date
	 */
	private static String getPrettyDate(Comment comment) {
		// Format to use when reading in data
		DateTimeFormatter iso8601Format = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
		// This object stores the date and time so that we can re-format it in a nicer
		// format
		LocalDateTime dateTimeData = iso8601Format.parse(comment.getSnippet().getPublishedAt(), LocalDateTime::from);
		// This is a much nicer format to view data in.
		DateTimeFormatter niceFormat = DateTimeFormatter.ofPattern(DATE_TIME_FORMAT);
		// Convert the date and time into that nicer format
		String dateTimeString = dateTimeData.format(niceFormat) + " GMT";
		// Return that nice-looking date and time. Lookin' good, datetime.
		return dateTimeString;
	}

	/**
	 * Generates a URL for the given Comment object from the video ID and the
	 * comment ID.
	 * 
	 * @param comment the Comment to generate a URL for
	 * @return a URL string linking to the given Comment
	 */
	private static String getURLForComment(Comment comment) {
		// All URLs are going to start with this general link
		String prefix = "https://www.youtube.com/watch";
		// Video argument is the video ID that the comment is on
		String video = "v=" + comment.getSnippet().getVideoId();
		// Comment argument is the id of this comment
		String cid = "lc=" + comment.getId();
		// Stitch the URL together with ? and & syntax to give variables to the URL
		String url = prefix + "?" + video + "&" + cid;
		// All done! Send it back to the user.
		return url;
	}

	/**
	 * Gets the day that Anxley posted this log
	 * 
	 * @param comment the Anxley comment to check
	 * @throws NumberFormatException if the comment cannot be parsed
	 * @return the day it was logged
	 */
	private static int getDayFromComment(Comment comment) {
		// Get the comment string itself
		String commentStr = comment.getSnippet().getTextDisplay();

		// Special cases
		// Day 1 has a bunch of stuff at the start before the entry itself
		if (commentStr.substring(0, 10).equals("Im doing t")) {
			return 1;
		}
		// Day 72 has an extra colon after "Day" and before "72"
		else if (commentStr.substring(0, 10).equals("Day: 72: I")) {
			return 72;
		}

		// Expecting the general format of:
		// Day ###: ...
		// Strategy to get that ###: Find the first space and the first colon, get
		// everything between the two, and convert to an int.

		// Find the first colon in the comment
		int colonIdx = commentStr.indexOf(":");
		// Find the first space in the comment
		int spaceIdx = commentStr.indexOf(" ");
		// If this doesn't have the format we expect, we might run into trouble
		try {
			// Get just the characters we want: those between the space and the colon.
			String intStr = commentStr.substring(spaceIdx + 1, colonIdx);
			// Try to read those characters as a number. If successful, return that number
			// as the day that this comment matches to.
			return Integer.parseInt(intStr);
		}
		// Either getting the substring or parsing the string as a number can throw an
		// exception
		catch (StringIndexOutOfBoundsException | NumberFormatException e) {
			// If either of these problems arise, tell the caller that the comment they
			// passed us couldn't be read
			throw new IllegalArgumentException();
		}
	}
}